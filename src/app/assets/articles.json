[
  {
    "id": 1,
    "article_name": "Introduction to Data Structures",
    "tags": ["SWE, DS"],
    "date": "2023-05-15",
    "content": "<p>In computer science there is one concept present in all languages and that is data structures. Though depending on the language you are using the implementation may vary but generally how they operate the their use cases are consistent.</p><section><h2>What is a data structure?</h2><p>A data structure is a way to organize and store data so it can be used efficiently. It provides ways to access and manipulate the data. Different types of data have different needs, for example if you wished to store many strings the means to store that data varies greatly from something like audio files. Additionally and maybe more importantly is the expected use case for the data, suppose the use case is adding data in a sequential manner like a transaction tracker, in this case the most used operation will be adding transactions as the user makes them. So we will want a data structure that performs well when adding data values to the end of the structure like a doubly Linked list. But if the task is searching for an element when indexing is impossible a treelike structure may perform better or a hash-map/set may be the better choice.</p></section><section><h2>Evaluation metrics</h2><p>When evaluating what is the best data structure for your use case there are two things to pay attention to: time complexity and space (storage) complexity.</p><h3>Evaluating time complexity</h3><p>Time complexity refers to the amount of time any one task requires. It is often represented in Big O notation which represents the worst case scenario for the task. Formally it is represented by f(x) &isin; O(g(x)) where f(x) is the runtime function that is being evaluated and g(x) is the comparative function. Such that O(g(x)) represents the worst case of f(x)). With this we can evaluate the difference between structures especially as x increases, providing a measure of scalability.</p><p>Here are some of the most common tasks for data structures:</p><ol><li>Insertion - Adding new elements</li><li>Deletion - Removing existing elements</li><li>Lookup - searching for a value</li><li>Retrieval - looking up a value given an index or key</li></ol><h3>Evaluating storage complexity</h3><p>Space complexity refers the to the amount of storage used to store data in relation to the number of elements x. Similarly to time complexity it also uses Big O notation, so all the information above applies.</p></section><section><h2>Common structures</h2><section><h4>Array</h4><p>A data structure that stores elements in a contiguous block of memory, where each element is directly accessible by an integer index starting from 0. <strong>Properties:</strong> sequential, indexable, searchable, contains duplicate values, fixed size (static arrays)</p><ol><li><strong>Access</strong> - O(1)<ol><li>Direct access to element using index</li></ol></li><li><strong>Search</strong> - O(n) (linear search), O(log n) (binary search if sorted)<ol><li>Linear search: iterate through array until value is found</li><li>Binary search: only possible on sorted arrays</li></ol></li><li><strong>Insertion</strong> - O(n) average/worst case, O(1) best case (end insertion)<ol><li>All elements to the right of insertion point need to be shifted right</li></ol></li><li><strong>Deletion</strong> - O(n) average/worst case, O(1) best case (end deletion)<ol><li>All elements to the right need to be shifted left</li></ol></li><li><strong>Space Complexity:</strong> O(n)</li></ol></section><section><h4>Linked List (doubly)</h4><p>A data structure where each value is stored independently from each other, with pointers connecting it to both its previous and next neighbors. <strong>Properties:</strong> sequential, searchable, dynamic size, contains duplicate values, no random access</p><ol><li><strong>Access</strong> - O(n)<ol><li>Must traverse from head or tail to reach desired position</li></ol></li><li><strong>Search</strong> - O(n) (linear search)<ol><li>Traverse through the list until value is found</li></ol></li><li><strong>Insertion</strong> - O(1) if position is known, O(n) if searching for position<ol><li>Adjust the pointers of neighbors once position is located</li></ol></li><li><strong>Deletion</strong> - O(1) if node reference is known, O(n) if searching for value<ol><li>Adjust the pointers of neighbors after locating the node</li></ol></li><li><strong>Space Complexity:</strong> O(n)</li></ol></section><section><h4>Heap (Binary Heap)</h4><p>A complete binary tree in which every parent node satisfies the heap property: in a max heap each parent is greater than or equal to its children, in a min heap each parent is less than or equal to its children. No ordering is enforced among siblings. <strong>Properties:</strong> complete binary tree, dynamic size, contains duplicate values, priority queue implementation</p><ol><li><strong>Access</strong> (peek min/max) - O(1) (peek), O(n) (arbitrary value)<ol><li>To access any of the elements within the heap iterating over the entire heap is required.</li></ol></li><li><strong>Search</strong> - O(n)<ol><li>Must check all elements as heap doesn&apos;t maintain search order beyond parent-child relationship</li></ol></li><li><strong>Insertion</strong> - O(log n)<ol><li>Insert at next available position, then bubble up while heap property is violated</li></ol></li><li><strong>Deletion</strong> (extract min/max) - O(log n)<ol><li>Remove root, replace with last element, then bubble down to restore heap property</li></ol></li><li><strong>Space Complexity:</strong> O(n)</li></ol></section><section><h4>Queue</h4><p>A linear data structure that follows the First-In, First-Out (FIFO) principle, where elements are added at the end and removed from the beginning. <strong>Properties:</strong> FIFO ordering, dynamic size, can contain duplicates</p><ol><li><strong>Access</strong> (front element) - O(1)<ol><li>Direct access to the front element (peek operation)</li></ol></li><li><strong>Search</strong> - O(n)<ol><li>Must examine elements from front to rear until value is found</li></ol></li><li><strong>Insertion</strong> (enqueue) - O(1)<ol><li>Add element to the rear of the queue</li></ol></li><li><strong>Deletion</strong> (dequeue) - O(1)<ol><li>Remove element from the front of the queue</li></ol></li><li><strong>Space Complexity:</strong> O(n)</li></ol></section><section><h4>Stack</h4><p>A linear data structure that follows the Last-In, First-Out (LIFO) principle, where elements are added and removed only from the top. <strong>Properties:</strong> dynamic size, can contain duplicates</p><ol><li><strong>Insertion</strong> - O(1)<ol><li>Directly push the element to the top of the stack</li></ol></li><li><strong>Deletion</strong> - O(1)<ol><li>Remove the element from the top of the stack (pop operation)</li></ol></li><li><strong>Lookup</strong> - O(n) (linear search)<ol><li>To find a value iterate through the stack until it is found</li></ol></li><li><strong>Retrieval</strong> - O(1)<ol><li>Access the top element directly (peek operation)</li></ol></li><li><strong>Space Complexity:</strong> O(n)</li></ol></section><section><h4>Map</h4><p>A data structure that stores key–value pairs, where each key is unique and provides direct access to its associated value. These keys are unique such that we cannot have more than one key of the same value. <strong>Properties:</strong> unique keys, key-value pairs, searchable by key</p><ol><li><strong>Insertion</strong> - O(n)<ol><li>Insert the key-value pair</li></ol></li><li><strong>Deletion</strong> - O(n)<ol><li>Remove the key-value pair and restructure if necessary</li></ol></li><li><strong>Lookup</strong> - O(n)<ol><li>Search for the key using the map&apos;s ordering structure</li></ol></li><li><strong>Retrieval</strong> - O(n)<ol><li>Access the value associated with a specific key</li></ol></li><li><strong>Space Complexity:</strong> O(n)</li></ol></section><section><h4>Hash Maps</h4><p>A data structure that stores key–value pairs and uses a hash function to compute the key of each value, enabling efficient average-case constant-time access, insertion, and deletion. <strong>Properties:</strong> unique keys, key-value pairs, uses hash function for indexing</p><ol><li><strong>Insertion</strong> - O(1)<ol><li>Calculate hash of key and insert at the computed index, handle collisions if necessary</li></ol></li><li><strong>Deletion</strong> - O(1)<ol><li>Calculate hash of key, find the entry, and remove it</li></ol></li><li><strong>Lookup</strong> - O(1)<ol><li>Calculate hash of key and search at the computed index</li></ol></li><li><strong>Retrieval</strong> - O(1)<ol><li>Calculate hash of key and access value at the computed index</li></ol></li><li><strong>Space Complexity:</strong> O(n)</li></ol></section><section><h4>Tree</h4><p>A hierarchical data structure consisting of nodes, with a single root node and zero or more child nodes, organized by parent–child relationships and containing no cycles. <strong>Properties:</strong> hierarchical structure, root node, parent-child relationships, no cycles</p><h5>Binary Search Tree (balanced)</h5><p>One common tree structure is the Binary Search Tree (BST), where each node’s left child contains values less than the node, and its right child contains values greater than the node, ensuring an ordered hierarchy for efficient searching and insertion.</p><ol><li><strong>Insertion</strong> - O(log n)<ol><li>Traverse from root to find appropriate position and insert new node</li></ol></li><li><strong>Deletion</strong> - O(log n)<ol><li>Find the node to delete and restructure tree to maintain properties</li></ol></li><li><strong>Lookup</strong> - O(log n)<ol><li>Traverse from root using comparison operations to find target value</li></ol></li><li><strong>Retrieval</strong> - O(log n)<ol><li>Navigate tree structure to access specific node or value</li></ol></li><li><strong>Space Complexity:</strong> O(n)</li></ol></section></section><section><h2>Choosing the right structure</h2><p>There are many more data structures than those covered here, and each comes with its own variations and optimizations. In the end, the key is to understand the operations your project will rely on most often and select the data structure that best supports those tasks.</p></section>"
  }
]